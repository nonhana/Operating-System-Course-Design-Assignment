## 一、实验介绍

在这个实验中，你将学习到系统调用的基本原理以及实验，动手实现一个自己的系统调用，并为它编写相应的测试用例。

## 二、实验目的

1. 掌握系统调用的实现原理
2. 掌握RISC-V架构下系统调用的方式
3. 学会编写系统调用，并能编写相应的用例加以测试

## 三、实验要求

1. 编写实现要求的系统调用
2. 编写相应用户程序进行调用测试
3. 提交代码

## 四、实验步骤

你需要实现的系统调用：`echo(char *str, int len)`，它的功能十分简单：读取字符串并打印出来。

### 1. 系统调用表

在项目的根目录下的`entry`文件夹中打开`syscall.tbl`文件，你会看到如下列表：

![img](https://hdu-tmp.oss-cn-hangzhou.aliyuncs.com/images/uploads/2023-05-25/MIWNjren9V.png)



三列数据分别对应着**系统调用号**，**系统调用名**以及**系统调用接口函数名**。请参照表内已有部分添加你的系统调用，注意你的系统调用号不是强制的，但必需确保是唯一的！（若需要提交，请保证系统调用号为666）

添加完你的系统调用表项后，尝试运行（`./run-qemu.sh`），看看会发生什么？

### 2. 系统调用定义

在上一部分你已经成功添加了你自己的系统调用表项，构建系统将会自动为你生成系统调用的声明等信息，你现在要做的就是要定义你的系统调用。

在内核源代码目录下（`src`）添加一个新的源文件（例如`sys_echo.c`），然后在其中实现你的系统调用：

```c
#include "common.h"
#include "mm/vm.h"
#include "kernel/syscall.h"

uint64_t sys_echo() {
	// ...
}
```

你可能会注意到，该定义中并没有显示给出系统调用的参数，原因是系统调用的参数传递与普通过程调用参数传递方式不太一致，需要通过*特殊方法*获取。事实上，正常函数参数可以从寄存器或栈中获取，而系统调用的参数则要从陷入时保存的上下文中获取。

> *一些提示*
>
> 1. 使用`kprintf`（区分于用户程序中的`printf`）来打印输出，如果遇到函数提示报红，未定义等问题，可以尝试`include "common.h"`来解决。
> 2. 通常情况下，我们返回0表示系统调用成功，否则失败。
> 3. 可以使用`argXXX`系列函数来帮助你获取系统调用的参数，它们被定义在`include/kernel/syscall.h`中。
> 4. 我们无法直接访问用户态传入的指针所指向的内存位置，可以使用`copy_from_user`函数来完成从用户态到内核态的内存拷贝，参见`include/mm/vm.h`。

在实现完成之后，你需要*编辑新增源文件所在目录下的`Makefile`文件*，将其链接至内核当中：

```shell
obj-y+=sys_echo.o # 替换为：你的源文件文件名 + .o
```

### 3. 编写测试程序

在`user/src`目录下创建你的测试C程序（例如`test_echo.c`），编写你的测试代码，例如：

```c
#include "string.h"
#include "syscall.h"

// 你的系统调用号
#define SYS_ECHO 666

int main(int argc, char **argv) {
	char *str = "Test String";
    int len = strlen(str);
    syscall(SYS_ECHO, str, len);
    return 0; 
}
```

编写完毕后，输入 `./run-qemu.sh` 运行内核，在出现的shell中输入`ls`列出当前目录下的所有文件，你会看到刚刚添加的 `test_echo` 测试程序，输入 `./test_echo` 执行它，观察输出结果。

## 五、思考

1. 如果去掉`syscall.tbl`中的系统调用声明，重新执行我们的测试程序，结果为何？系统是否崩溃？
2. 在`syscall.tbl`中添加表项生成系统调用声明的原理？
3. 系统调用参数具体是如何获取的？
4. 在RISC-V指令集架构中，如何调用系统调用？