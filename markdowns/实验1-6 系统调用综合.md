## 一、实验介绍

在这个实验中，你将学习如何编写一个具有实用价值的系统调用 **`trace`** 。

## 二、实验目的

1. 掌握系统调用的实现原理
2. 掌握RISC-V架构下系统调用的方式
3. 学会编写系统调用，并能编写相应的用例加以测试
4. 理解并掌握UNIX系统下，进程建立和组织的形式
5. 了解进程创建与克隆的基本过程

## 三、实验要求

1. 编写实现要求的系统调用
2. 编写相应用户程序进行调用测试
3. 提交代码

## 四、实验步骤

### 1. 添加系统调用声明

在`entry/syscall.tbl`中添加该项系统调用的相关信息表项。在这里，**我们约定系统调用号为`524`**。

### 2. 实现功能

在`src`目录下的任意`.c`文件中添加在上一小节中指定的系统调用接口定义，实现该系统调用所要求的功能。

#### 功能描述

```
trace(syscall_num)
参数：syscall_num 系统调用号
功能：监控当前进程接下来的系统调用，若发生`syscall_num`对应的系统调用，则打印输出此次系统调用的相关信息。此外，该进程的子进程也将会继承此监听项。
```

#### 调用示例

```c
#include "syscall.h"
#include "unistd.h"
#include "stdio.h"

int main() {
    // 监听172号(getpid)系统调用
    syscall(524, 172);
    // 第一次调用
    getpid();
    // fork产生子进程
    if (fork() == 0) {
        // 子进程调用
        getpid();
    } else {
        // 父进程取消监听
        syscall(524, -1);
        // 父进程调用
        getpid();
    }

    return 0;
}

// 输出：
// trace: PID X calls getpid
// trace: PID X+1 calls getpid
```

> *一些提示*
>
> 1. 可以将需要目标系统调用存储在进程结构体（PCB）中，以便于每次进入系统调用时，都能从进程上下文中知晓当前监控的系统调用号。
> 2. 在`fork/clone`过程中需要继承相关监听项。
> 3. 在新建PCB过程中需要注意初始化。
> 4. 使用`syscall_name(num)`获取系统调用的名称。

修改用例，观察输出的结果会发生什么变化？是否与预期一致？

## 五、思考

1. 如何实现同时监听多个系统调用？
2. 对于`fork/clone`系统调用而言，监听它们与普通的系统调用有什么区别？