## 一、实验介绍

在这个实验中，你将完成一个打印内存布局的基础设施。

## 二、实验目的

1. 掌握侵入式链表的基本操作
2. 了解进程内存空间是如何被组织和管理的

## 三、实验要求

1. 完成实验要求的基础设施代码，并测试
2. 提交代码

## 四、实验步骤

得益于mmu这样的硬件，OS可以将进程的内存空间进行隔离，对于每个进程来说，都有一个独立可访问的内存空间，而一个程序通常由指令以及数据构成，两者的区别在执行权限上尤为明显（指令可读可执行，数据不可执行但可读可写），在具体的体系结构中，我们往往通过页表项中的权限比特位来对这些段分别做权限保护。通常情况下，指令和数据往往分别位于一段连续的空间上，这被称之为一个段，例如指令段，数据段等。在我们的OS中，我们通过一个叫做`vma(Virtual Memory Area)`的结构体来对这样的段进行描述和记录，而这些`vma`被统一组织在`mm(MeMory layout)`这样一个结构体中，你的任务是**遍历**一个`mm`结构，并打印其中的所有`vma`信息：

```c
void mmap_print(mm_t *mm) {
    vma_t *vma;
    int id = 1;

    // TODO:
    // iterate vma linklist led with mm->vma_head
    // print the order and vma info
}
```

它将具有类似如下的输出：

```
1. vma@0x802f1788: 0x10000--0x12000 len: 0x2000 rwxu anonymous
2. vma@0x802f17f0: 0x12000--0x13000 len: 0x1000 rwxu anonymous
```

你可以在`src/kernel/exec.c:110`插入该函数调用，以打印加载完成的待执行程序的内存空间。

> *一些提示*
>
> 1. 可以使用`vma_print`来帮助你打印具体的`vma`信息