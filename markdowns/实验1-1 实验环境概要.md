## 一、实验介绍

本章节将会针对我们的实验环境做一个简要的说明。

## 二、实验目的

通过对实验环境的了解，理解后续实验操作的目的和意图。你将会了解到：

- 这个项目是如何组织的
- 这个项目是如何构建的
- 这个项目你能够学习的

## 三、实验要求

理解实验环境的运作方式，掌握重要的实验常用操作命令

## 四、实验步骤

### 1. 项目的结构

我们目前只需要重点关注`src`, `user`以及根目录下的几个`.sh`脚本文件即可。

```
(root)
├── bootloader       # bootloader(SBI)
├── changelog        # 项目的更新日志
├── .editorconfig    # 代码格式化规范（https://editorconfig.org）
├── entry   
│   └── syscall.tbl  # 系统调用表
├── include          # 头文件目录
├── Makefile         # 构建脚本
├── README.md        # 实验指导说明
├── run-gdb.sh       # GDB调试脚本
├── run-k210.sh      # K210板子上的启动脚本
├── run-qemu.sh      # 正常启动的脚本
├── script           # 用来存放构建用的一些自动化脚本文件
├── src              # 内核源文件目录
├── tools            # 存放一些常用的工具
└── user             # 用户程序目录
    ├── CMakeLists.txt
    ├── include
    ├── lib
    ├── Makefile
    ├── raw          # 文件夹内的所有文件将被直接拷贝到文件镜像中
    └── src          # 源文件目录（每一个源文件对应一个二进制可执行文件，在构建后被拷贝到文件镜像中）
```

`src`目录下存放的是关于内核的所有源文件。除了内核以外，我们还有读写文件、执行文件系统内可执行程序的需求，因此我们还需要一个文件镜像作为我们操作系统可执行读写操作的虚拟磁盘，而这个镜像中的内容正是由`user`目录所决定的。为了满足可以编写用户程序动态测试内核功能的需求，我们也提供了自动构建用户程序的机制，只需要在`user/src`下创建或者修改源文件，即可自动构建出一个对应的可执行二进制文件并拷贝至文件镜像中以供执行。

### 2. 编译与运行

在命令行输入：

```shell
$ ./run-qemu.sh
```

你将会看到内核与文件镜像被自动构建生成，并在QEMU中运行。

如果运行成功你将会看到：

```
▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄ ▄▄▄   ▄ ▄▄▄▄▄▄▄    ▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄ 
█▓▓▓▓▓▓▓█       █▓▓▓▓▓▓▓█       █▓▓▓█ █▓█       █  █▓▓▓▓▓▓▓█▓▓▓▓▓▓▓█
█▄     ▄█   ▄   █▄     ▄█   ▄   █   █▄█ █   ▄   █  █   ▄   █  ▄▄▄▄▄█
  █   █ █  █▄█  █ █   █ █  █▄█  █      ▄█  █▄█  █  █  █ █  █ █▄▄▄▄▄ 
  █   █ █       █ █   █ █       █     █▄█       █  █  █▄█  █▄▄▄▄▄  █
  █   █ █   ▄   █ █   █ █   ▄   █    ▄  █   ▄   █  █       █▄▄▄▄▄█ █
  █▄▄▄█ █▄▄█ █▄▄█ █▄▄▄█ █▄▄█ █▄▄█▄▄▄█ █▄█▄▄█ █▄▄█  █▄▄▄▄▄▄▄█▄▄▄▄▄▄▄█

hart 0 start
Lab 1 - Overview

🎉 Kernel starts successfully!
😉 You are supposed to run test() in user/src/init0.c if you are ready to submit📤 your code.
😘 Enjoy it!
child welcome exited with 0
```

恭喜，你已经成功运行了它！

下面来看看`run-qemu.sh`到底做了什么：

```shell
#!/bin/sh
make run platform=qemu CPUS=1 $*
```

- `make run`指定了我们的目标是`run`
- `platform=qemu`指定了我们的目标平台是QEMU（还可以是K210）
- `CPUS=1`指定了核心线程数

所以说在命令行中直接执行`make run platform=qemu CPUS=1`也是完全没有问题的，使用脚本纯粹是为了便捷起见。除了以上几个可以指定的构建选项以外，还可以参考根目录下的Makefile文件说明。

以上操作已经完全满足了我们构建的需要，出于篇幅限制，我们无法阐释构建系统的细节，如果你对我们的构建系统感兴趣，请参考[使用Makefile构建](http://gitlab.ji-sang.com/yztz/tatakos/-/blob/master/doc/使用Makefile构建.md),[平台化的开发构建](http://gitlab.ji-sang.com/yztz/tatakos/-/blob/master/doc/平台化的开发构建.md) 。

### 3. 前置的要求

1. 汇编 & C语言

本项目基于C11标准编写，在进行本实验之前，学习者请务必掌握C语言的基础语法（尤其是指针的概念），此外还需要了解部分C语言内联汇编语法与汇编语言的编写（这部分只要求做到会百度即可）。

1. 操作系统与编译原理前置课程学习

本课程面向于已有前置课程经验的学习者设计。

1. 基本的Linux使用。

### 4. 通过本课程能够学习

1. 远超操作系统理论课实践作业的实践经历。
2. 深入理解操作系统理论课程学习的相关概念。
3. RISC-V指令集特权级架构。

### 5. 完善本项目和课程

如果你有任何问题，欢迎积极反馈交流本项目和课程，请提交issue至本项目的主仓库[议题 · tatakOS](http://gitlab.ji-sang.com/yztz/tatakos/-/issues) 。

### 6. 完成本节的提交

// TODO